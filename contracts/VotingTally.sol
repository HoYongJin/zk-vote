// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title IVerifier
 * @dev Interface for the Groth16 Verifier contract generated by snarkjs.
 * This allows the VotingTally contract to call the `verifyProof` function.
 */
interface IVerifier {
    function verifyProof(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[3] memory input // public outputs: [root, vote_index, nullifier_hash]
    ) external view returns (bool r);
}

/**
 * @title VotingTally
 * @dev This contract tallies votes using ZK-SNARK proofs to ensure anonymity and prevent double-voting.
 * It works in conjunction with a Verifier contract.
 */
contract VotingTally {
    // --- State Variables ---

    address public owner;
    IVerifier public immutable verifier;        // The verifier contract is immutable for security.
    uint256 public immutable electionId;        // The unique ID for this election is also immutable.

    uint256 public merkleRoot;
    uint256 public votingStartTime;
    uint256 public votingEndTime;
    uint256 public numCandidates;               // Total number of candidates for this election.

    // Mapping from candidate index to their vote count.
    mapping(uint256 => uint256) public voteCounts;

    // Mapping to store used nullifiers to prevent double-voting.
    mapping(uint256 => bool) public usedNullifiers;


    // --- Events ---

    event VoteCast(uint256 indexed electionId, uint256 indexed candidateIndex);
    event MerkleRootSet(uint256 root);
    event VotingPeriodSet(uint256 startTime, uint256 endTime);


    // --- Modifier ---

    modifier onlyOwner() {
        require(msg.sender == owner, "VotingTally: Caller is not the owner");
        _;
    }


    // --- Constructor ---

    /**
     * @dev Sets up the contract with the Verifier address, election ID, and number of candidates.
     * @param _verifierAddress The address of the deployed Groth16Verifier contract.
     * @param _electionId A unique ID for this election.
     * @param _numCandidates The total number of valid candidates (e.g., 3 for indices 0, 1, 2).
     */
    constructor(address _verifierAddress, uint256 _electionId, uint256 _numCandidates) {
        owner = msg.sender;
        verifier = IVerifier(_verifierAddress);
        electionId = _electionId;
        numCandidates = _numCandidates;
    }


    // --- Admin Functions ---

    /**
     * @dev Sets the Merkle root of the voter list, effectively starting the election setup.
     * Can only be called by the owner.
     * @param _root The Merkle root generated by the off-chain server.
     */
    function setMerkleRoot(uint256 _root) external onlyOwner {
        require(_root != 0, "VotingTally: Merkle root cannot be zero");
        merkleRoot = _root;
        emit MerkleRootSet(_root);
    }

    /**
     * @dev Sets the voting period.
     * Can only be called by the owner.
     */
    function setVotingPeriod(uint256 _startTime, uint256 _endTime) external onlyOwner {
        require(_startTime < _endTime, "VotingTally: Start time must be before end time");
        votingStartTime = _startTime;
        votingEndTime = _endTime;
        emit VotingPeriodSet(_startTime, _endTime);
    }


    // --- Vote Submission ---

    /**
     * @dev Submits a ZK proof to cast a vote. Verifies the proof and records the vote if valid.
     * @param a The ZK proof component 'a'.
     * @param b The ZK proof component 'b'.
     * @param c The ZK proof component 'c'.
     * @param publicInputs The public inputs array: [merkleRoot, voteIndex, nullifierHash].
     */
    function submitTally(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[3] memory publicInputs
    ) external {
        // 1. Check if the voting period is active.
        require(block.timestamp >= votingStartTime, "VotingTally: Voting has not started yet");
        require(block.timestamp < votingEndTime, "VotingTally: Voting has ended");

        // 2. Check if the election has been properly configured with a Merkle root.
        require(merkleRoot != 0, "VotingTally: Merkle root is not set");
        
        // 3. Verify that the Merkle root in the proof matches the one set in the contract.
        require(publicInputs[0] == merkleRoot, "VotingTally: Invalid Merkle root");

        // 4. Prevent double-voting by checking the nullifier.
        uint256 nullifierHash = publicInputs[2];
        require(!usedNullifiers[nullifierHash], "VotingTally: This vote has already been cast");

        // 5. Validate candidate index is within the valid range.
        uint256 candidateIndex = publicInputs[1];
        require(candidateIndex < numCandidates, "VotingTally: Invalid candidate index");

        // 6. Call the Verifier contract to validate the ZK proof. This is the core check.
        bool isValid = verifier.verifyProof(a, b, c, publicInputs);
        require(isValid, "VotingTally: Invalid ZK proof");

        // 7. If all checks pass, record the nullifier and increment the vote count.
        usedNullifiers[nullifierHash] = true;
        voteCounts[candidateIndex]++;

        // 7. Emit an event to log the successful vote.
        emit VoteCast(electionId, candidateIndex);
    }
}
